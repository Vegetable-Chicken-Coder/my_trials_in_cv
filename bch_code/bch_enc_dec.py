# -*- coding: utf-8 -*-
"""
Spyder Editor

This is a temporary script file.
"""
import bchlib
import torch
import numpy as np

BCH_POLYNOMIAL = 137 #设置控制编码的多项式
BCH_BITS = 5#设置编码的字节数
bch = bchlib.BCH(BCH_POLYNOMIAL, BCH_BITS)
print(bch.ecc_bytes)#bch的编码字节数（此时为5）

#%% 1. 编码encode
secret = "stega!!"#编码信息
#bytearray为可变长字节数组，1字节=8bit,data共56bit
data = bytearray(secret + ' ' * (7 - len(secret)), 'utf-8')#将字符串转化为utf-8编码并存储进bytearray中
ecc = bch.encode(data)#获得对应编码,ecc共5x8=40 bit
packet = data + ecc#对数据进行编码,packet共56+40=96bit
packet_binary = ''.join(format(x, '08b') for x in packet)#转换成二进制字符串类型
secret = [int(x) for x in packet_binary]#转换为100维数组
secret.extend([0, 0, 0, 0])#补齐100位

#%% 2. 解码decode
#一个可以正确解码的secret
#secret = [1.9726343e-04, 9.9995732e-01, 1.4403163e-02, 9.9989998e-01, 3.2109518e-03, 1.7337262e-04, 9.9995935e-01, 9.9999356e-01, 1.7456773e-03, 8.3012325e-01, 9.9932384e-01, 9.9579632e-01, 2.1652711e-04, 9.9936253e-01, 2.6705340e-02, 1.0111470e-02, 2.0944967e-04, 9.9986196e-01, 9.9992895e-01, 1.4587844e-04, 1.3290808e-03, 9.9820161e-01, 4.5936060e-04, 9.8889261e-01, 2.8514978e-05, 9.9996030e-01, 9.9743891e-01, 2.7680828e-03, 7.3751587e-05, 6.3216776e-01, 9.9622571e-01, 9.9999595e-01, 4.7229361e-04, 9.8636222e-01, 9.9999082e-01, 3.3737794e-02, 1.5274387e-04, 2.6010837e-02, 5.6549083e-03, 9.9864012e-01, 9.6286880e-05, 9.2296209e-04, 9.9940443e-01, 7.9065328e-05, 4.5878213e-04, 6.4041064e-04, 6.1945379e-05, 9.9746299e-01, 2.6480577e-06, 2.9768348e-02, 9.9931467e-01, 4.7158104e-04, 6.8083345e-03, 1.6871499e-03, 1.1385337e-02, 9.9711943e-01, 9.9933439e-01, 1.3352779e-02, 9.1192359e-04, 1.6077032e-03, 9.9787533e-01, 4.5975067e-02, 1.7656437e-01, 1.6350081e-03, 9.8850727e-01, 2.1020496e-02, 9.9871194e-01, 7.6898950e-04, 9.9507648e-01, 2.5933809e-03, 1.7141878e-03, 9.9994004e-01, 9.9991238e-01, 9.9888581e-01, 9.9992907e-01, 9.5696461e-01, 9.9605465e-01, 2.0038245e-04, 9.9989140e-01, 9.9990857e-01, 6.9913361e-04, 9.9835265e-01, 6.3097976e-02, 1.1943448e-03, 9.9864858e-01, 9.9607891e-01, 9.8410356e-01, 4.0903818e-04, 2.7812346e-05, 9.9945658e-01, 4.9499143e-04, 2.9761606e-04, 3.2283799e-05, 2.3621314e-03, 3.4468595e-02, 9.1244420e-04, 7.0816447e-04, 8.3490089e-03, 3.3554494e-05, 1.1802505e-03]

#一个会被错误解码的secret
secret = [3.44927572e-02, 8.26512516e-01, 1.96039930e-01, 1.07639156e-01, 2.33461708e-01, 9.99370873e-01, 5.26997924e-01, 7.92610526e-01, 1.24039866e-01, 9.73501861e-01, 9.86873329e-01, 7.37463117e-01, 2.47921292e-02, 8.70735109e-01, 1.90964907e-01, 2.12293118e-02, 7.33909011e-02, 8.02239299e-01, 9.86379564e-01, 2.11315714e-02, 1.29406393e-01, 9.75822926e-01, 2.19570518e-01, 7.51555502e-01, 4.69446123e-01, 9.41252112e-01, 9.91189003e-01, 6.12970054e-01, 1.64033189e-01, 3.94395320e-03, 9.11519289e-01, 3.99727613e-01, 2.18758553e-01, 2.98759341e-01, 9.79980230e-01, 8.53618681e-01, 4.53619361e-01, 9.95488837e-04, 2.20226854e-01, 9.82924640e-01, 1.20939672e-01, 3.10687006e-01, 3.36412072e-01, 2.03666106e-01, 1.64314002e-01, 7.17752753e-03, 7.94558525e-01, 7.67858773e-02, 3.58260535e-02, 7.28566825e-01, 9.86103833e-01, 3.33807081e-01, 4.53836322e-01, 5.63829720e-01, 1.93397120e-01, 5.58501065e-01, 6.53754294e-01, 9.56765473e-01, 2.34471500e-01, 7.45498300e-01, 6.64404571e-01, 3.63409556e-02, 2.83436403e-02, 4.36525196e-02, 6.46496117e-01, 1.41763806e-01, 8.49039435e-01, 3.97451855e-02, 9.44551885e-01, 2.22096369e-01, 5.38621750e-03, 9.69812572e-01, 8.50955844e-01, 8.11480343e-01, 2.03631461e-01, 2.81059206e-01, 8.08005393e-01, 5.67586087e-02, 8.14846873e-01, 9.88562226e-01, 3.59764159e-01, 9.54651535e-01, 1.65275469e-01, 1.53507680e-01, 7.77474225e-01, 9.95935678e-01, 9.98145938e-01, 6.54009357e-02, 6.60484970e-01, 9.62519288e-01, 3.38087648e-01, 1.00100629e-01, 8.91588449e-01, 1.08009242e-01, 8.21508467e-02, 1.16938844e-01, 7.21091032e-02, 9.80695009e-01, 8.97652566e-01, 1.78345829e-01]
secret = np.array(secret)
secret = np.round(secret)
packet_binary = "".join([str(int(bit)) for bit in secret[:96]])#提取前96位二进制，转换为字符串类型
packet=[int(packet_binary[i:i+8],2) for i in range(0,len(packet_binary),8)]#将字符串中每8位按照二进制数读取为int型数组
packet=bytes(packet)#转换为byte类型
packet = bytearray(packet)#转换为bytearray
data, ecc = packet[:-bch.ecc_bytes], packet[-bch.ecc_bytes:]#分离数据与编码
bitflips = bch.decode_inplace(data, ecc)#纠错，该步实际上已经对data进行了修改
#bitflips, data, ecc = bch.decode(data, ecc)#纠错
if bitflips != -1:#如果错误位数小于纠错位数（字节数）                                  
    code = data.decode("utf-8")#按照utf-8将字节解码回字符串                       
    print(code)                                                             
else:#如果错误位数大于最大纠错位数（字节数）  
    print('Failed to decode')

